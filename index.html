<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>March Madness Archive</title>
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --surface: rgba(15, 23, 42, 0.82);
      --surface-light: rgba(255, 255, 255, 0.08);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --border: rgba(148, 163, 184, 0.25);
      --shadow: 0 18px 40px rgba(15, 23, 42, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100dvh;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding-top: calc(52px + env(safe-area-inset-top));
      overflow: hidden;
    }

    main {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .tab-panel {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px;
      display: none;
    }

    .tab-panel.active {
      display: flex;
      flex-direction: column;
    }

    .tab-bar {
      display: flex;
      gap: 4px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.92));
      padding: calc(env(safe-area-inset-top) + 6px) 8px 6px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    .tab-btn {
      flex: 1;
      background: none;
      border: none;
      color: var(--muted);
      font-size: 0.75rem;
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 6px 4px;
      border-radius: 8px;
      transition: all 0.15s ease;
      cursor: pointer;
    }

    .tab-btn svg {
      width: 18px;
      height: 18px;
    }

    .tab-btn.active {
      color: var(--accent);
      background: var(--accent-soft);
    }

    .panel-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .panel-card h2 {
      margin: 0 0 10px;
      font-size: 1rem;
      font-weight: 600;
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    label {
      font-size: 0.8rem;
      color: var(--muted);
    }

    select, button.primary {
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      padding: 8px 10px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
    }

    select:focus, button.primary:focus {
      outline: none;
      border-color: var(--accent);
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent), #3b82f6);
      border: none;
    }

    button.primary:active {
      opacity: 0.9;
    }

    .view-toggle {
      display: flex;
      gap: 4px;
      background: rgba(15, 23, 42, 0.5);
      padding: 4px;
      border-radius: 8px;
      margin-left: auto;
    }

    .view-toggle button {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 0.75rem;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }

    .view-toggle button.active {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .bracket-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      width: 100%;
    }

    .round-column h3 {
      margin: 0 0 8px;
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .game-card {
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.15);
      padding: 8px;
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 6px;
    }

    .game-card.highlight {
      border-color: rgba(56, 189, 248, 0.5);
    }

    .team-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
    }

    .team-row.winner {
      color: var(--accent);
      font-weight: 600;
    }

    .team-meta {
      font-size: 0.65rem;
      color: var(--muted);
      margin-top: 2px;
    }

    /* Tree Bracket View */
    .bracket-tree {
      display: none;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: 8px;
    }

    .bracket-tree.active {
      display: block;
    }

    .bracket-tree-inner {
      display: flex;
      gap: 8px;
      min-width: max-content;
    }

    .tree-round {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      min-width: 130px;
    }

    .tree-round-label {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--muted);
      padding: 4px 0 8px;
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 2;
    }

    .tree-game {
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 8px;
      margin: 4px 0;
      font-size: 0.7rem;
      position: relative;
    }

    .tree-game::after {
      content: '';
      position: absolute;
      right: -8px;
      top: 50%;
      width: 8px;
      height: 1px;
      background: var(--border);
    }

    .tree-round:last-child .tree-game::after {
      display: none;
    }

    .tree-team {
      display: flex;
      justify-content: space-between;
      padding: 2px 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tree-team.winner {
      color: var(--accent);
      font-weight: 600;
    }

    .tree-seed {
      color: var(--muted);
      font-size: 0.65rem;
      min-width: 16px;
    }

    .stat-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .stat-table th, .stat-table td {
      padding: 8px 6px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      text-align: left;
    }

    .stat-table th {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .stat-table th.sortable {
      cursor: pointer;
      user-select: none;
      color: var(--muted);
    }

    .stat-table th.sortable::after {
      content: '';
      margin-left: 2px;
    }

    .stat-table th.sortable.active-asc::after {
      content: '‚Üë';
    }

    .stat-table th.sortable.active-desc::after {
      content: '‚Üì';
    }

    .stat-table tbody tr:active {
      background: rgba(56, 189, 248, 0.1);
    }

    .clickable-row {
      cursor: pointer;
    }

    .win-bar {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .win-bar-fill {
      height: 4px;
      background: var(--accent);
      border-radius: 2px;
      min-width: 2px;
    }

    .subtab-bar {
      display: flex;
      gap: 4px;
      background: rgba(15, 23, 42, 0.5);
      padding: 4px;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .subtab-btn {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--muted);
      font-weight: 500;
      padding: 8px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .subtab-btn.active {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .subtab-panel {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .subtab-panel.active {
      display: block;
    }

    .tag-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(56, 189, 248, 0.12);
      border: 1px solid rgba(56, 189, 248, 0.25);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      margin-right: 8px;
    }

    .empty-state {
      padding: 24px;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.3);
      text-align: center;
      color: var(--muted);
    }

    .seed-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
    }

    .seed-card {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.15);
      background: rgba(15, 23, 42, 0.6);
    }

    .seed-card h4 {
      margin: 0 0 8px;
      font-size: 0.8rem;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .sim-output {
      margin-top: 12px;
    }

    .loading {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .loading span {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 3px solid rgba(56, 189, 248, 0.35);
      border-top-color: var(--accent);
      animation: spin 0.9s linear infinite;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.75);
      backdrop-filter: blur(14px);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 24px;
      z-index: 200;
    }

    .modal-overlay[hidden] {
      display: none;
    }

    .modal-content {
      width: min(540px, 100%);
      max-height: 80vh;
      overflow-y: auto;
      background: rgba(15, 23, 42, 0.92);
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 22px 60px rgba(15, 23, 42, 0.45);
      padding: 24px;
      color: var(--text);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 18px;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 1.2rem;
      cursor: pointer;
    }

    .modal-close:hover {
      color: var(--accent);
    }

    .game-history-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .game-history-item {
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(15, 23, 42, 0.55);
    }

    .game-history-item strong {
      color: var(--accent);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 640px) {
      .modal-content {
        max-height: 90dvh;
        max-height: 90vh;
        padding: 16px;
        border-radius: 16px;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
      }

      .control-row label {
        margin-bottom: -4px;
      }
    }

    @media (max-width: 820px) {
      .bracket-grid {
        display: flex;
        overflow-x: auto;
        gap: 12px;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
      }

      .bracket-grid::-webkit-scrollbar {
        display: none;
      }

      .round-column {
        flex: 0 0 160px;
        scroll-snap-align: start;
      }
    }
  </style>
</head>
<body>
  <nav class="tab-bar" role="tablist">
    <button class="tab-btn active" id="nav-brackets" data-tab="brackets" aria-controls="tab-brackets" aria-selected="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4h6v6H4z"/><path d="M14 4h6v6h-6z"/><path d="M4 14h6v6H4z"/><path d="M14 14h6v6h-6z"/>
      </svg>
      Brackets
    </button>
    <button class="tab-btn" id="nav-insights" data-tab="insights" aria-controls="tab-insights" aria-selected="false">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 3v18"/><path d="M3 17l4-4 4 4 8-8 2 2"/>
      </svg>
      Insights
    </button>
    <button class="tab-btn" id="nav-sim" data-tab="sim" aria-controls="tab-sim" aria-selected="false">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
      </svg>
      Sim
    </button>
  </nav>

  <div class="app" role="application">
    <main>
      <section id="tab-brackets" class="tab-panel active" aria-labelledby="nav-brackets">
        <div class="panel-card">
          <div class="control-row">
            <label for="yearSelect">Year</label>
            <select id="yearSelect" aria-label="Select tournament year"></select>
            <div class="view-toggle">
              <button class="active" data-view="list">List</button>
              <button data-view="tree">Tree</button>
            </div>
          </div>
          <div id="bracketSummary" class="muted" style="font-size:0.8rem;"></div>
        </div>

        <div class="panel-card" style="flex:1; overflow:hidden; display:flex; flex-direction:column;">
          <div id="bracketView" class="bracket-grid" style="flex:1; overflow:auto;"></div>
          <div id="bracketTreeView" class="bracket-tree"></div>
        </div>
      </section>

      <section id="tab-insights" class="tab-panel" aria-labelledby="nav-insights">
        <div class="panel-card" style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
          <div class="subtab-bar" role="tablist">
            <button class="subtab-btn active" data-subtab="team-history" aria-selected="true">Teams</button>
            <button class="subtab-btn" data-subtab="seed-rounds" aria-selected="false">Seeds</button>
            <button class="subtab-btn" data-subtab="seed-matchups" aria-selected="false">Matchups</button>
          </div>

          <div id="subtab-team-history" class="subtab-panel active" role="tabpanel" style="flex:1; overflow:auto;">
            <div class="muted" id="teamHistorySummary" style="font-size:0.75rem; margin-bottom:8px;"></div>
            <table class="stat-table" aria-describedby="teamHistorySummary" data-team-table="true">
              <thead>
                <tr>
                  <th scope="col" class="sortable" data-sort="team">Team</th>
                  <th scope="col" class="sortable" data-sort="titles">üèÜ</th>
                  <th scope="col" class="sortable" data-sort="wins">W</th>
                  <th scope="col" class="sortable" data-sort="losses">L</th>
                  <th scope="col" class="sortable" data-sort="winPct">%</th>
                </tr>
              </thead>
              <tbody id="teamHistoryTable"></tbody>
            </table>
          </div>

          <div id="subtab-seed-rounds" class="subtab-panel" role="tabpanel" style="flex:1; overflow:auto;">
            <div id="seedRoundGrid" class="seed-grid"></div>
          </div>

          <div id="subtab-seed-matchups" class="subtab-panel" role="tabpanel" style="flex:1; overflow:auto;">
            <table class="stat-table">
              <thead>
                <tr>
                  <th scope="col">Matchup</th>
                  <th scope="col">G</th>
                  <th scope="col">Low%</th>
                  <th scope="col">High%</th>
                </tr>
              </thead>
              <tbody id="seedMatchupTable"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="tab-sim" class="tab-panel" aria-labelledby="nav-sim">
        <div class="panel-card">
          <div class="control-row">
            <label for="simYearSelect">Year</label>
            <select id="simYearSelect" aria-label="Select a bracket for simulation"></select>
            <label for="simModeSelect">Mode</label>
            <select id="simModeSelect" aria-label="Select simulation mode">
              <option value="seed-record">Seed record</option>
              <option value="random">Random</option>
              <option value="legacy">Legacy</option>
              <option value="team-win-pct">Win %</option>
              <option value="team-total-wins">Total W</option>
              <option value="team-titles">Titles</option>
              <option value="seed-weighted">Weighted</option>
            </select>
            <button class="primary" id="simulateBtn">Run</button>
          </div>
          
          <details style="margin-top:8px;">
            <summary style="cursor:pointer; color:var(--accent); font-size:0.8rem; font-weight:500;">Custom Field</summary>
            <div style="margin-top:8px; padding:10px; border:1px dashed var(--border); border-radius:8px;">
              <textarea id="customTeams" placeholder="64 teams, one per line..." style="width:100%; height:80px; background:rgba(15,23,42,0.7); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:8px; font-size:0.75rem; font-family:inherit; resize:none;"></textarea>
              <div style="margin-top:6px; display:flex; gap:6px;">
                <button class="primary" id="fillDummyBtn" style="background:var(--surface-light); font-size:0.75rem; padding:6px 10px;">Dummy</button>
                <button class="primary" id="clearCustomBtn" style="background:var(--surface-light); font-size:0.75rem; padding:6px 10px;">Clear</button>
              </div>
            </div>
          </details>
        </div>

        <div class="panel-card" style="flex:1; overflow:hidden; display:flex; flex-direction:column;">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
            <div id="simStats" class="tag-pill" style="display:none; font-size:0.7rem; padding:4px 8px;"></div>
            <div id="simSummary" class="muted" style="font-size:0.8rem;"></div>
          </div>
          <div id="simBracket" class="bracket-grid" style="flex:1; overflow:auto;"></div>
        </div>
      </section>
    </main>
  </div>

    <div id="teamModal" class="modal-overlay" hidden>
      <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="teamModalTitle">
        <div class="modal-header">
          <div>
            <h3 id="teamModalTitle"></h3>
            <div id="teamModalSubtitle" class="muted"></div>
          </div>
          <button class="modal-close" id="teamModalClose" aria-label="Close team history dialog">&times;</button>
        </div>
        <div id="teamModalBody">
          <ul id="teamModalList" class="game-history-list"></ul>
        </div>
      </div>
    </div>

  <template id="loadingTemplate">
    <div class="loading" role="status">
      <span aria-hidden="true"></span>
      <strong>Loading tournaments‚Ä¶</strong>
    </div>
  </template>

  <script>
    const YEAR_START = 1985;
    const YEAR_END = 2025;
    const ROUND_SEQUENCE = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];

    const state = {
      tournaments: new Map(),
      aggregated: null,
      currentYear: null,
      loaded: false,
      teamSort: { key: 'titles', direction: 'desc' },
      bracketView: 'list',
    };

    document.addEventListener('DOMContentLoaded', () => {
      setupTabs();
      setupSubtabs();
      setupViewToggle();
      setupTeamTableInteractions();
      setupModalControls();
      bootstrap();
    });

    async function bootstrap() {
      renderLoading();
      await loadAllTournaments();
      populateYearSelectors();
      computeAggregatedStats();
      hydrateInsights();
      state.loaded = true;
      const defaultYear = state.tournaments.size ? Math.max(...state.tournaments.keys()) : YEAR_END;
      setActiveYear(defaultYear);
    }

    function setupTabs() {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.classList.contains('active')) return;
          document.querySelectorAll('.tab-btn').forEach(b => {
            b.classList.toggle('active', b === btn);
            b.setAttribute('aria-selected', b === btn ? 'true' : 'false');
          });
          document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `tab-${btn.dataset.tab}`);
          });
        });
      });
    }

    function setupSubtabs() {
      document.querySelectorAll('.subtab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.subtab;
          document.querySelectorAll('.subtab-btn').forEach(b => {
            const isActive = b === btn;
            b.classList.toggle('active', isActive);
            b.setAttribute('aria-selected', isActive ? 'true' : 'false');
          });
          document.querySelectorAll('.subtab-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `subtab-${target}`);
          });
        });
      });
    }

    function setupViewToggle() {
      document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.dataset.view;
          state.bracketView = view;
          document.querySelectorAll('.view-toggle button').forEach(b => b.classList.toggle('active', b === btn));
          document.getElementById('bracketView').style.display = view === 'list' ? '' : 'none';
          document.getElementById('bracketTreeView').classList.toggle('active', view === 'tree');
          if (view === 'tree' && state.currentYear) {
            renderBracketTree(state.currentYear);
          }
        });
      });
    }

    function renderLoading() {
      const bracketView = document.getElementById('bracketView');
      const simBracket = document.getElementById('simBracket');
      const template = document.getElementById('loadingTemplate');
      bracketView.replaceChildren(template.content.cloneNode(true));
      simBracket.replaceChildren(template.content.cloneNode(true));
    }

    async function loadAllTournaments() {
      const fetches = [];
      for (let year = YEAR_START; year <= YEAR_END; year++) {
        if (year === 2020) {
          console.info('Skipping 2020 tournament data (season canceled).');
          continue;
        }
        const url = `json/tournament-${year}.json`;
        fetches.push(fetch(url)
          .then(resp => {
            if (!resp.ok) throw new Error(`Missing dataset ${year}`);
            return resp.json().then(data => state.tournaments.set(year, data));
          })
          .catch(() => {
            console.warn(`Tournament data not found for ${year}, skipping.`);
          }));
      }
      await Promise.all(fetches);
    }

    function populateYearSelectors() {
      const yearOptions = Array.from(state.tournaments.keys()).sort((a, b) => b - a);
      const yearSelect = document.getElementById('yearSelect');
      const simYearSelect = document.getElementById('simYearSelect');
      yearOptions.forEach(year => {
        const option = new Option(year, year);
        yearSelect.add(option.cloneNode(true));
        simYearSelect.add(option);
      });
      yearSelect.addEventListener('change', event => setActiveYear(Number(event.target.value)));
      document.getElementById('simulateBtn').addEventListener('click', () => runSimulation());
      document.getElementById('fillDummyBtn').addEventListener('click', () => fillDummyTeams());
      document.getElementById('clearCustomBtn').addEventListener('click', () => {
        document.getElementById('customTeams').value = '';
      });
    }

    function fillDummyTeams() {
      const dummies = Array.from({ length: 64 }, (_, i) => `Team ${i + 1}`);
      document.getElementById('customTeams').value = dummies.join('\n');
    }

    function setActiveYear(year) {
      if (!state.tournaments.has(year)) return;
      state.currentYear = year;
      document.getElementById('yearSelect').value = year;
      document.getElementById('simYearSelect').value = year;
      renderBracket(year);
      renderBracketSummary(year);
      if (state.bracketView === 'tree') {
        renderBracketTree(year);
      }
    }

    function renderBracket(year) {
      const data = state.tournaments.get(year);
      const roundOrder = [
        { key: 'round1', label: 'R64' },
        { key: 'round2', label: 'R32' },
        { key: 'sweet16', label: 'S16' },
        { key: 'elite8', label: 'E8' },
        { key: 'finalFour', label: 'F4' },
        { key: 'championship', label: 'Final' },
      ];
      const container = document.getElementById('bracketView');
      container.innerHTML = '';
      roundOrder.forEach(round => {
        const column = document.createElement('div');
        column.className = 'round-column';
        const header = document.createElement('h3');
        header.textContent = round.label;
        column.appendChild(header);
        if (round.key === 'championship') {
          column.appendChild(renderChampionshipCard(data.rounds.championship));
        } else {
          const games = data.rounds[round.key] || [];
          games.forEach(game => column.appendChild(renderGameCard(game, round.key === 'finalFour')));
        }
        container.appendChild(column);
      });
    }

    function renderBracketTree(year) {
      const data = state.tournaments.get(year);
      if (!data) return;
      const container = document.getElementById('bracketTreeView');
      container.innerHTML = '';
      
      const inner = document.createElement('div');
      inner.className = 'bracket-tree-inner';
      
      const roundOrder = [
        { key: 'round1', label: 'R64' },
        { key: 'round2', label: 'R32' },
        { key: 'sweet16', label: 'Sweet 16' },
        { key: 'elite8', label: 'Elite 8' },
        { key: 'finalFour', label: 'Final 4' },
        { key: 'championship', label: 'Championship' },
      ];
      
      roundOrder.forEach(round => {
        const col = document.createElement('div');
        col.className = 'tree-round';
        
        const label = document.createElement('div');
        label.className = 'tree-round-label';
        label.textContent = round.label;
        col.appendChild(label);
        
        if (round.key === 'championship') {
          const final = data.rounds.championship;
          if (final) {
            col.appendChild(renderTreeGame(final));
          }
        } else {
          const games = data.rounds[round.key] || [];
          games.forEach(game => col.appendChild(renderTreeGame(game)));
        }
        
        inner.appendChild(col);
      });
      
      container.appendChild(inner);
    }

    function renderTreeGame(game) {
      const card = document.createElement('div');
      card.className = 'tree-game';
      
      const t1 = document.createElement('div');
      t1.className = 'tree-team' + (game.winner === game.team1 ? ' winner' : '');
      t1.innerHTML = `<span class="tree-seed">${game.seed1 ?? ''}</span> ${game.team1 || 'TBD'}`;
      
      const t2 = document.createElement('div');
      t2.className = 'tree-team' + (game.winner === game.team2 ? ' winner' : '');
      t2.innerHTML = `<span class="tree-seed">${game.seed2 ?? ''}</span> ${game.team2 || 'TBD'}`;
      
      card.appendChild(t1);
      card.appendChild(t2);
      return card;
    }

    function renderGameCard(game, highlight = false) {
      const card = document.createElement('article');
      card.className = 'game-card';
      if (highlight) card.classList.add('highlight');
      const teams = [
        { team: game.team1, seed: game.seed1, score: game.score1 },
        { team: game.team2, seed: game.seed2, score: game.score2 },
      ];
      teams.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'team-row';
        const isWinner = entry.team === game.winner;
        if (isWinner) row.classList.add('winner');
        row.innerHTML = `<span>${entry.seed ?? '?'} ${entry.team || 'TBD'}</span><span>${entry.score ?? ''}</span>`;
        card.appendChild(row);
      });
      return card;
    }

    function renderChampionshipCard(final) {
      if (!final) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = 'No data';
        return empty;
      }
      const card = document.createElement('article');
      card.className = 'game-card highlight';
      const teams = [
        { team: final.team1, seed: final.seed1, score: final.score1 },
        { team: final.team2, seed: final.seed2, score: final.score2 },
      ];
      teams.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'team-row';
        if (entry.team === final.winner) row.classList.add('winner');
        row.innerHTML = `<span>${entry.seed ?? '?'} ${entry.team}</span><span>${entry.score ?? ''}</span>`;
        card.appendChild(row);
      });
      const meta = document.createElement('div');
      meta.className = 'team-meta';
      const championSeed = resolveWinnerSeed(final);
      meta.innerHTML = [`Champion: ${final.winner}`, championSeed ? `Seed ${championSeed}` : ''].filter(Boolean).join(' ¬∑ ');
      card.appendChild(meta);
      return card;
    }

    function renderBracketSummary(year) {
      const data = state.tournaments.get(year);
      const summary = document.getElementById('bracketSummary');
      summary.innerHTML = `üèÜ ${data.champion} (${data.championSeed}) def. ${data.runnerUp} (${data.runnerUpSeed})`;
    }

    function resolveWinnerSeed(game) {
      if (!game || !game.winner) return null;
      if (game.winner === game.team1) return game.seed1 ?? null;
      if (game.winner === game.team2) return game.seed2 ?? null;
      return null;
    }

    function computeAggregatedStats() {
      const teamMap = new Map();
      const seedRoundMap = new Map();
      const matchupMap = new Map();
      const roundKeys = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour'];

      const tournaments = Array.from(state.tournaments.values());
      tournaments.forEach(tournament => {
        const championStats = ensureTeam(teamMap, tournament.champion);
        if (championStats) championStats.titles += 1;
        const runnerStats = ensureTeam(teamMap, tournament.runnerUp);
        if (runnerStats) runnerStats.runnerUp += 1;
        (tournament.finalFour || []).forEach(entry => {
          const teamStats = ensureTeam(teamMap, entry.team);
          if (teamStats) teamStats.finalFour += 1;
        });

        roundKeys.forEach(roundKey => {
          const playedThisRound = new Set();
          (tournament.rounds[roundKey] || []).forEach(game => {
            // Check for placeholder/duplicate teams in the same round
            if (playedThisRound.has(game.team1) || playedThisRound.has(game.team2)) {
              return; // Skip duplicate matchups in same round (placeholder data)
            }
            if (!game.team1 || !game.team2 || game.team1 === game.team2) return;
            
            playedThisRound.add(game.team1);
            playedThisRound.add(game.team2);
            
            registerRoundGame(seedRoundMap, teamMap, roundKey, game, tournament.year);
            registerMatchup(matchupMap, game);
          });
        });
        
        const final = tournament.rounds.championship;
        if (final && final.team1 && final.team2 && final.team1 !== final.team2) {
          registerChampionship(seedRoundMap, matchupMap, teamMap, final, tournament.year);
        }
      });

      state.aggregated = {
        teamHistory: teamMap,
        seedRounds: seedRoundMap,
        matchups: matchupMap,
        totalSeasons: tournaments.length,
      };
    }

    function ensureTeam(map, teamName) {
      if (!teamName) return null;
      if (!map.has(teamName)) {
        map.set(teamName, { titles: 0, runnerUp: 0, finalFour: 0, wins: 0, losses: 0, games: [] });
      }
      return map.get(teamName);
    }

    function registerRoundGame(seedRoundMap, teamMap, roundKey, game, year) {
      if (!game) return;
      updateSeedRound(seedRoundMap, roundKey, game.seed1, game.winner === game.team1);
      updateSeedRound(seedRoundMap, roundKey, game.seed2, game.winner === game.team2);
      recordTeamResult(teamMap, year, roundKey, game);
    }

    function registerChampionship(seedRoundMap, matchupMap, teamMap, final, year) {
      if (!final) return;
      registerRoundGame(seedRoundMap, teamMap, 'championship', {
        team1: final.team1,
        seed1: final.seed1,
        team2: final.team2,
        seed2: final.seed2,
        winner: final.winner,
        score1: final.score1,
        score2: final.score2,
      }, year);
      registerMatchup(matchupMap, {
        seed1: final.seed1,
        seed2: final.seed2,
        team1: final.team1,
        team2: final.team2,
        winner: final.winner,
      });
    }

    function recordTeamResult(teamMap, year, roundKey, game) {
      const { team1, team2, winner, seed1, seed2, score1, score2 } = game;
      if (!team1 || !team2 || team1 === team2) return;
      const stats1 = ensureTeam(teamMap, team1);
      const stats2 = ensureTeam(teamMap, team2);
      if (!stats1 || !stats2) return;
      const roundLabel = friendlyRound(roundKey);
      const team1Win = winner === team1;
      const team2Win = winner === team2;
      if (team1Win) {
        stats1.wins += 1;
        stats2.losses += 1;
      } else if (team2Win) {
        stats2.wins += 1;
        stats1.losses += 1;
      }

      stats1.games.push({
        year,
        roundKey,
        round: roundLabel,
        opponent: team2,
        teamSeed: seed1 ?? null,
        opponentSeed: seed2 ?? null,
        result: team1Win ? 'W' : 'L',
        teamScore: typeof score1 === 'number' ? score1 : null,
        opponentScore: typeof score2 === 'number' ? score2 : null,
      });

      stats2.games.push({
        year,
        roundKey,
        round: roundLabel,
        opponent: team1,
        teamSeed: seed2 ?? null,
        opponentSeed: seed1 ?? null,
        result: team2Win ? 'W' : 'L',
        teamScore: typeof score2 === 'number' ? score2 : null,
        opponentScore: typeof score1 === 'number' ? score1 : null,
      });
    }

    function updateSeedRound(seedRoundMap, roundKey, seed, isWinner) {
      if (typeof seed !== 'number') return;
      if (!seedRoundMap.has(roundKey)) seedRoundMap.set(roundKey, new Map());
      const roundMap = seedRoundMap.get(roundKey);
      if (!roundMap.has(seed)) roundMap.set(seed, { games: 0, wins: 0 });
      const entry = roundMap.get(seed);
      entry.games += 1;
      if (isWinner) entry.wins += 1;
    }

    function registerMatchup(matchupMap, game) {
      if (typeof game.seed1 !== 'number' || typeof game.seed2 !== 'number') return;
      const lowerSeed = Math.min(game.seed1, game.seed2);
      const higherSeed = Math.max(game.seed1, game.seed2);
      const key = `${lowerSeed}-${higherSeed}`;
      if (!matchupMap.has(key)) {
        matchupMap.set(key, { lowerSeed, higherSeed, games: 0, lowerWins: 0, higherWins: 0 });
      }
      const entry = matchupMap.get(key);
      entry.games += 1;
      if (resolveWinnerSeed(game) === lowerSeed) {
        entry.lowerWins += 1;
      } else {
        entry.higherWins += 1;
      }
    }

    function hydrateInsights() {
      if (!state.aggregated) return;
      renderTeamHistory();
      renderSeedRounds();
      renderSeedMatchups();
    }

    function renderTeamHistory() {
      const { teamHistory } = state.aggregated;
      const rows = Array.from(teamHistory.entries()).map(([team, stats]) => {
        const totalGames = stats.wins + stats.losses;
        const winPctValue = totalGames ? stats.wins / totalGames : 0;
        return {
          team,
          titles: stats.titles,
          runnerUp: stats.runnerUp,
          finalFour: stats.finalFour,
          wins: stats.wins,
          losses: stats.losses,
          winPct: winPctValue,
        };
      });

      const direction = state.teamSort.direction === 'asc' ? 1 : -1;
      rows.sort((a, b) => {
        const key = state.teamSort.key;
        if (key === 'team') {
          return a.team.localeCompare(b.team) * direction;
        }
        const valA = a[key] ?? 0;
        const valB = b[key] ?? 0;
        if (valA === valB) {
          return a.team.localeCompare(b.team) * direction;
        }
        return (valA > valB ? 1 : -1) * direction;
      });

      const tbody = document.getElementById('teamHistoryTable');
      tbody.innerHTML = '';
      rows.forEach(entry => {
        const row = document.createElement('tr');
        const totalGames = entry.wins + entry.losses;
        const winPct = totalGames ? (entry.winPct * 100).toFixed(0) : '0';
        row.dataset.team = entry.team;
        row.classList.add('clickable-row');
        row.innerHTML = `
          <td>${entry.team}</td>
          <td>${entry.titles || '-'}</td>
          <td>${entry.wins}</td>
          <td>${entry.losses}</td>
          <td><div class="win-bar"><div class="win-bar-fill" style="width:${Math.min(winPct, 100) * 0.4}px"></div>${winPct}%</div></td>
        `;
        tbody.appendChild(row);
      });
      document.getElementById('teamHistorySummary').textContent = `${teamHistory.size} teams ¬∑ Tap to view history`;
      updateTeamSortIndicators();
    }

    function renderSeedRounds() {
      const container = document.getElementById('seedRoundGrid');
      container.innerHTML = '';
      const order = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];
      const labels = {
        round1: 'R64',
        round2: 'R32',
        sweet16: 'S16',
        elite8: 'E8',
        finalFour: 'F4',
        championship: 'Final',
      };
      order.forEach(roundKey => {
        const roundMap = state.aggregated.seedRounds.get(roundKey);
        if (!roundMap) return;
        const card = document.createElement('section');
        card.className = 'seed-card';
        const heading = document.createElement('h4');
        heading.textContent = labels[roundKey];
        heading.style.fontSize = '0.85rem';
        heading.style.marginBottom = '8px';
        card.appendChild(heading);
        const list = document.createElement('div');
        list.style.display = 'grid';
        list.style.gridTemplateColumns = 'repeat(2, 1fr)';
        list.style.gap = '4px';
        list.style.fontSize = '0.7rem';
        const seeds = Array.from(roundMap.entries()).sort((a, b) => a[0] - b[0]);
        seeds.forEach(([seed, record]) => {
          const winRate = record.games ? ((record.wins / record.games) * 100).toFixed(0) : '0';
          const entry = document.createElement('div');
          entry.style.color = 'var(--muted)';
          entry.innerHTML = `<span style="color:var(--text)">${seed}:</span> ${winRate}%`;
          list.appendChild(entry);
        });
        card.appendChild(list);
        container.appendChild(card);
      });
    }

    function renderSeedMatchups() {
      const table = document.getElementById('seedMatchupTable');
      table.innerHTML = '';
      const records = Array.from(state.aggregated.matchups.values())
        .filter(entry => entry.games >= 2)
        .sort((a, b) => b.games - a.games);
      records.forEach(entry => {
        const row = document.createElement('tr');
        const lowerRate = entry.games ? ((entry.lowerWins / entry.games) * 100).toFixed(0) : '0';
        const higherRate = entry.games ? ((entry.higherWins / entry.games) * 100).toFixed(0) : '0';
        const barWidth = Math.round(parseFloat(lowerRate) * 0.5);
        row.innerHTML = `
          <td>${entry.lowerSeed}v${entry.higherSeed}</td>
          <td>${entry.games}</td>
          <td><div class="win-bar"><div class="win-bar-fill" style="width:${barWidth}px"></div>${lowerRate}%</div></td>
          <td>${higherRate}%</td>
        `;
        table.appendChild(row);
      });
    }

    function setupTeamTableInteractions() {
      const table = document.querySelector('[data-team-table]');
      if (!table || table.dataset.enhanced) return;
      table.dataset.enhanced = 'true';
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      if (thead) {
        thead.addEventListener('click', event => {
          const target = event.target.closest('[data-sort]');
          if (!target) return;
          const sortKey = target.dataset.sort;
          if (!sortKey) return;
          if (state.teamSort.key === sortKey) {
            state.teamSort.direction = state.teamSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            state.teamSort.key = sortKey;
            state.teamSort.direction = sortKey === 'team' ? 'asc' : 'desc';
          }
          if (state.aggregated) renderTeamHistory();
        });
      }
      if (tbody) {
        tbody.addEventListener('click', event => {
          const row = event.target.closest('tr[data-team]');
          if (!row) return;
          openTeamModal(row.dataset.team);
        });
      }
    }

    function updateTeamSortIndicators() {
      document.querySelectorAll('[data-sort]').forEach(th => {
        th.classList.remove('active-asc', 'active-desc');
        if (th.dataset.sort === state.teamSort.key) {
          th.classList.add(state.teamSort.direction === 'asc' ? 'active-asc' : 'active-desc');
        }
      });
    }

    function setupModalControls() {
      const overlay = document.getElementById('teamModal');
      if (!overlay || overlay.dataset.enhanced) return;
      overlay.dataset.enhanced = 'true';
      const closeBtn = document.getElementById('teamModalClose');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeTeamModal);
      }
      overlay.addEventListener('click', event => {
        if (event.target === overlay) closeTeamModal();
      });
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape' && !overlay.hasAttribute('hidden')) {
          closeTeamModal();
        }
      });
    }

    function openTeamModal(teamName) {
      if (!teamName || !state.aggregated) return;
      const overlay = document.getElementById('teamModal');
      if (!overlay) return;
      const stats = state.aggregated.teamHistory.get(teamName);
      if (!stats) return;
      const title = document.getElementById('teamModalTitle');
      const subtitle = document.getElementById('teamModalSubtitle');
      const list = document.getElementById('teamModalList');
      if (title) title.textContent = teamName;
      const totalGames = stats.wins + stats.losses;
      const winPct = totalGames ? ((stats.wins / totalGames) * 100).toFixed(1) : '0.0';
      if (subtitle) subtitle.textContent = `${stats.wins}-${stats.losses} (${winPct}%) since ${YEAR_START}`;
      if (list) {
        list.innerHTML = '';
        const history = stats.games.slice().sort((a, b) => {
          if (a.year !== b.year) return b.year - a.year;
          const indexA = ROUND_SEQUENCE.indexOf(a.roundKey);
          const indexB = ROUND_SEQUENCE.indexOf(b.roundKey);
          const safeA = indexA === -1 ? ROUND_SEQUENCE.length : indexA;
          const safeB = indexB === -1 ? ROUND_SEQUENCE.length : indexB;
          if (safeA === safeB) {
            return a.opponent.localeCompare(b.opponent);
          }
          return safeA - safeB;
        });
        if (!history.length) {
          const empty = document.createElement('li');
          empty.className = 'game-history-item';
          empty.textContent = 'No recorded games for this program.';
          list.appendChild(empty);
        } else {
          history.forEach(item => {
            const li = document.createElement('li');
            li.className = 'game-history-item';
            const resultLabel = item.result === 'W' ? 'Win' : 'Loss';
            const seeds = [
              typeof item.teamSeed === 'number' ? `Seed ${item.teamSeed}` : null,
              typeof item.opponentSeed === 'number' ? `vs Seed ${item.opponentSeed}` : null,
            ].filter(Boolean).join(' ¬∑ ');
            const scoreLine = (item.teamScore !== null && item.opponentScore !== null)
              ? `${item.teamScore}-${item.opponentScore}`
              : null;
            li.innerHTML = `
              <strong>${item.year} ¬∑ ${item.round}</strong>
              <div>${resultLabel} vs ${item.opponent}${seeds ? ` ¬∑ ${seeds}` : ''}</div>
              ${scoreLine ? `<div>Score: ${scoreLine}</div>` : ''}
            `;
            list.appendChild(li);
          });
        }
      }
      overlay.removeAttribute('hidden');
      document.body.style.overflow = 'hidden';
    }

    function closeTeamModal() {
      const overlay = document.getElementById('teamModal');
      if (!overlay || overlay.hasAttribute('hidden')) return;
      overlay.setAttribute('hidden', '');
      document.body.style.overflow = '';
    }

    function runSimulation() {
      if (!state.loaded || !state.aggregated) {
        alert('Datasets still loading. Try again in a moment.');
        return;
      }
      const yearSelect = document.getElementById('simYearSelect');
      const year = Number(yearSelect.value);
      const mode = document.getElementById('simModeSelect').value;
      const customInput = document.getElementById('customTeams').value.trim();
      
      let baseRounds;
      let usingCustom = false;

      if (customInput) {
        const teams = customInput.split('\n').map(t => t.trim()).filter(Boolean);
        if (teams.length < 64) {
          alert(`Please provide at least 64 teams (currently ${teams.length}).`);
          return;
        }
        usingCustom = true;
        baseRounds = { round1: buildCustomRound1(teams.slice(0, 64)) };
      } else {
        if (!state.tournaments.has(year)) return;
        baseRounds = state.tournaments.get(year).rounds;
      }

      const bracket = simulateBracket(baseRounds, mode);
      let accuracy = null;
      if (!usingCustom && state.tournaments.has(year)) {
        accuracy = calculateBracketAccuracy(bracket, state.tournaments.get(year).rounds);
      }
      
      renderSimulation(bracket, mode, accuracy);
    }

    function buildCustomRound1(teams) {
      const regions = ['East', 'West', 'Midwest', 'South'];
      const round1 = [];
      const seeds = [1, 16, 8, 9, 5, 12, 4, 13, 6, 11, 3, 14, 7, 10, 2, 15];
      
      for (let r = 0; r < 4; r++) {
        const region = regions[r];
        for (let s = 0; s < 16; s += 2) {
          const s1 = seeds[s];
          const s2 = seeds[s+1];
          const idx1 = r * 16 + s; // This is a simple linear map, logic can be tuned
          const idx2 = r * 16 + s + 1;
          round1.push({
            region,
            team1: teams[idx1] || `Team ${idx1+1}`, 
            seed1: s1,
            team2: teams[idx2] || `Team ${idx2+1}`, 
            seed2: s2
          });
        }
      }
      return round1;
    }

    function calculateBracketAccuracy(simulated, actual) {
      let matches = 0;
      let totalGames = 0;
      const keys = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour'];
      
      keys.forEach(k => {
        if (!simulated[k] || !actual[k]) return;
        simulated[k].forEach((game, i) => {
          if (actual[k][i] && game.winner === actual[k][i].winner) {
            matches++;
          }
          totalGames++;
        });
      });

      if (simulated.championship && actual.championship) {
        if (simulated.championship.winner === actual.championship.winner) {
          matches++;
        }
        totalGames++;
      }

      return totalGames > 0 ? (matches / totalGames * 100).toFixed(1) : 0;
    }

    function simulateBracket(rounds, mode) {
      const simulated = {};
      const baseRound = Array.isArray(rounds.round1) ? rounds.round1.map(game => ({ ...game })) : [];
      simulated.round1 = simulateRound(baseRound, mode);

      let previousRound = simulated.round1;
      ['round2', 'sweet16', 'elite8', 'finalFour'].forEach(key => {
        const nextMatchups = buildNextRound(previousRound);
        const simulatedRound = simulateRound(nextMatchups, mode);
        simulated[key] = simulatedRound;
        previousRound = simulatedRound;
      });

      simulated.championship = simulateChampionship(buildChampionship(simulated.finalFour), mode);
      return simulated;
    }

    function simulateRound(matchups, mode) {
      return matchups.map(game => ({
        team1: game.team1,
        team2: game.team2,
        seed1: game.seed1,
        seed2: game.seed2,
        region: game.region ?? null,
        winner: pickWinner(game, mode),
      }));
    }

    function buildNextRound(previousRoundGames) {
      const matchups = [];
      for (let i = 0; i < previousRoundGames.length; i += 2) {
        const gameA = previousRoundGames[i];
        const gameB = previousRoundGames[i + 1];
        if (!gameA || !gameB || !gameA.winner || !gameB.winner) continue;
        matchups.push({
          team1: gameA.winner,
          seed1: resolveWinnerSeed(gameA),
          team2: gameB.winner,
          seed2: resolveWinnerSeed(gameB),
          region: gameA.region === gameB.region ? gameA.region : gameA.region || gameB.region || null,
        });
      }
      return matchups;
    }

    function buildChampionship(finalFourGames) {
      if (!finalFourGames || finalFourGames.length < 2) return null;
      const [eastWest, midSouth] = finalFourGames;
      if (!eastWest?.winner || !midSouth?.winner) return null;
      return {
        team1: eastWest.winner,
        seed1: resolveWinnerSeed(eastWest),
        team2: midSouth.winner,
        seed2: resolveWinnerSeed(midSouth),
      };
    }

    function simulateChampionship(matchup, mode) {
      if (!matchup) return null;
      return {
        ...matchup,
        winner: pickWinner(matchup, mode),
      };
    }

    function pickWinner(game, mode) {
      const seed1 = game.seed1 ?? resolveSeedFromPreviousRound(game.team1);
      const seed2 = game.seed2 ?? resolveSeedFromPreviousRound(game.team2);
      const stats1 = state.aggregated?.teamHistory.get(game.team1);
      const stats2 = state.aggregated?.teamHistory.get(game.team2);

      switch (mode) {
        case 'random':
          return coinFlip(game.team1, game.team2);
        case 'legacy': {
          const score1 = legacyScore(game.team1);
          const score2 = legacyScore(game.team2);
          if (score1 === score2) return coinFlip(game.team1, game.team2);
          return score1 >= score2 ? game.team1 : game.team2;
        }
        case 'team-win-pct': {
          const pct1 = computeWinPct(stats1);
          const pct2 = computeWinPct(stats2);
          if (pct1 === null && pct2 === null) return coinFlip(game.team1, game.team2);
          if (pct1 === null) return game.team2;
          if (pct2 === null) return game.team1;
          if (pct1 === pct2) return coinFlip(game.team1, game.team2);
          return pct1 > pct2 ? game.team1 : game.team2;
        }
        case 'team-total-wins': {
          const wins1 = stats1?.wins ?? null;
          const wins2 = stats2?.wins ?? null;
          if (wins1 === null && wins2 === null) return coinFlip(game.team1, game.team2);
          if (wins1 === null) return game.team2;
          if (wins2 === null) return game.team1;
          if (wins1 === wins2) return coinFlip(game.team1, game.team2);
          return wins1 > wins2 ? game.team1 : game.team2;
        }
        case 'team-titles': {
          const titles1 = stats1?.titles ?? null;
          const titles2 = stats2?.titles ?? null;
          if (titles1 === null && titles2 === null) return coinFlip(game.team1, game.team2);
          if (titles1 === null) return game.team2;
          if (titles2 === null) return game.team1;
          if (titles1 === titles2) return coinFlip(game.team1, game.team2);
          return titles1 > titles2 ? game.team1 : game.team2;
        }
        case 'seed-weighted':
          return seedWeightedPick(game.team1, seed1, game.team2, seed2);
        case 'seed-record':
        default: {
          const probability = seedMatchupProbability(seed1, seed2);
          if (probability !== null) {
            return Math.random() <= probability ? game.team1 : game.team2;
          }
          if (!Number.isFinite(seed1) || !Number.isFinite(seed2)) {
            return coinFlip(game.team1, game.team2);
          }
          if (seed1 === seed2) return coinFlip(game.team1, game.team2);
          return seed1 < seed2 ? game.team1 : game.team2;
        }
      }
    }

    function resolveSeedFromPreviousRound(team) {
      if (!state.currentYear) return null;
      const rounds = state.tournaments.get(state.currentYear)?.rounds;
      if (!rounds) return null;
      const allRounds = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour', 'championship'];
      for (const roundKey of allRounds) {
        const games = Array.isArray(rounds[roundKey]) ? rounds[roundKey] : [rounds[roundKey]];
        for (const game of games) {
          if (!game) continue;
          if (game.team1 === team) return game.seed1;
          if (game.team2 === team) return game.seed2;
          if (game.winner === team) return resolveWinnerSeed(game);
        }
      }
      return null;
    }

    function legacyScore(team) {
      if (!team || !state.aggregated) return 0;
      const stats = state.aggregated.teamHistory.get(team);
      if (!stats) return 0;
      return stats.titles * 5 + stats.finalFour * 2 + stats.runnerUp;
    }

    function computeWinPct(stats) {
      if (!stats) return null;
      const total = stats.wins + stats.losses;
      if (!total) return null;
      return Number((stats.wins / total).toFixed(4));
    }

    function seedMatchupProbability(seed1, seed2) {
      if (typeof seed1 !== 'number' || typeof seed2 !== 'number' || !state.aggregated) return null;
      const lowerSeed = Math.min(seed1, seed2);
      const higherSeed = Math.max(seed1, seed2);
      const key = `${lowerSeed}-${higherSeed}`;
      const record = state.aggregated.matchups.get(key);
      if (!record || record.games < 3) return null;
      const lowerWinRate = record.lowerWins / record.games;
      return seed1 === lowerSeed ? lowerWinRate : 1 - lowerWinRate;
    }

    function renderSimulation(simulatedRounds, mode, accuracy = null) {
      const summary = document.getElementById('simSummary');
      const stats = document.getElementById('simStats');
      const container = document.getElementById('simBracket');
      const champion = simulatedRounds.championship?.winner;
      
      if (accuracy !== null) {
        stats.style.display = 'inline-flex';
        stats.textContent = `${accuracy}% match`;
      } else {
        stats.style.display = 'none';
      }

      summary.textContent = champion ? `üèÜ ${champion}` : 'Incomplete';
      container.innerHTML = '';
      const roundOrder = ['round1', 'round2', 'sweet16', 'elite8', 'finalFour'];
      roundOrder.forEach(roundKey => {
        const column = document.createElement('div');
        column.className = 'round-column';
        const heading = document.createElement('h3');
        heading.textContent = friendlyRound(roundKey);
        column.appendChild(heading);
        (simulatedRounds[roundKey] || []).forEach(game => column.appendChild(renderGameCard(game, roundKey === 'finalFour')));
        container.appendChild(column);
      });
      const finalColumn = document.createElement('div');
      finalColumn.className = 'round-column';
      const heading = document.createElement('h3');
      heading.textContent = 'Final';
      finalColumn.appendChild(heading);
      const finalCard = simulatedRounds.championship ? renderChampionshipCard(simulatedRounds.championship) : renderChampionshipCard(null);
      finalColumn.appendChild(finalCard);
      container.appendChild(finalColumn);
    }

    function modeLabel(mode) {
      switch (mode) {
        case 'seed-record':
          return 'seed-performance';
        case 'legacy':
          return 'legacy-weighted';
        case 'team-win-pct':
          return 'team win percentage';
        case 'team-total-wins':
          return 'historical win leader';
        case 'team-titles':
          return 'championship priority';
        case 'seed-weighted':
          return 'seed-weighted draw';
        default:
          return 'random draw';
      }
    }

    function seedWeightedPick(team1, seed1, team2, seed2) {
      if (!Number.isFinite(seed1) || !Number.isFinite(seed2)) {
        return coinFlip(team1, team2);
      }
      const total = seed1 + seed2;
      if (total <= 0) return coinFlip(team1, team2);
      const weight1 = Math.max(1, total - seed1);
      const weight2 = Math.max(1, total - seed2);
      const roll = Math.floor(Math.random() * (weight1 + weight2)) + 1;
      return roll <= weight1 ? team1 : team2;
    }

    function coinFlip(team1, team2) {
      return Math.random() < 0.5 ? team1 : team2;
    }

    function friendlyRound(roundKey) {
      switch (roundKey) {
        case 'round1': return 'R64';
        case 'round2': return 'R32';
        case 'sweet16': return 'S16';
        case 'elite8': return 'E8';
        case 'finalFour': return 'F4';
        default: return roundKey;
      }
    }
  </script>
</body>
</html>
